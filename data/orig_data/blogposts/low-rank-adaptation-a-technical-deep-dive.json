{
    "title": "Low Rank Adaptation: A Technical Deep Dive",
    "author": "Nikhil Nagaraj",
    "readTime": "10 min read",
    "publishDate": "May 23, 2023",
    "blocks": [
        {
            "type": "FIGURE",
            "filename": "af084f7123e71604fbbc31e4aa137860.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:700/0*JmBZ8Lwhe3UcfL84",
            "caption": "Photo by Google DeepMind on Unsplash"
        },
        {
            "type": "P",
            "content": "In todayâ€™s fast-paced technological landscape, large AI models are propelling breakthroughs across diverse domains. However, tailoring these models to specific tasks or datasets can be a computational and resource-intensive endeavor. Enter LoRA (Low Rank Adaptation) â€” a groundbreaking and efficient fine-tuning technique that harnesses the power of these advanced models for custom tasks and datasets without straining resources or incurring excessive costs."
        },
        {
            "type": "P",
            "content": "LoRA has taken the AI community by storm in recent months (Fig 1). In this blog post, weâ€™ll delve into the reasons behind its meteoric rise. Weâ€™ll explore the principles underpinning LoRA, its effectiveness in various domains, and the impact itâ€™s having on the open-source community."
        },
        {
            "type": "FIGURE",
            "filename": "f37e69daee64942ceafcd4cf69201881.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:700/1*CIvylICdcGILMXrPbqVP9Q.png",
            "caption": "Fig 1: Popularity of the term LoRA over the last 12 months within the Computer Science category. (Source)"
        },
        {
            "type": "P",
            "content": "Whether youâ€™re an AI aficionado, an engineer seeking to capitalize on large models for your specific business challenge, join us on this captivating journey to discover how LoRA is transforming the fine-tuning step in the FMOps (Foundation Model Ops) pipeline for large AI models."
        },
        {
            "type": "H1",
            "content": "Background Concepts"
        },
        {
            "type": "P",
            "content": "Before diving into LoRA, letâ€™s review some fundamental linear algebra concepts. If youâ€™re comfortable with the basics of linear algebra (particularly matrix rank), feel free to bypass the math below."
        },
        {
            "type": "H1",
            "content": "Matrix Rank"
        },
        {
            "type": "P",
            "content": "The rank of a matrix is the dimension of the vector space generated by its columns, which is given by the number of linearly independent columns (or rows) in a given matrix. It can be proven that the number of independent columns (known as column rank) is always equal to the number of independent rows (called row rank). Hence, for a matrix A with m rows and n columns (represented as Aâ‚˜â‚™),"
        },
        {
            "type": "FIGURE",
            "filename": "67a482e868338ec3d534329fb1a6b891.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:453/1*tNmst6mluR3AZjupaGk7MQ.png",
            "caption": null
        },
        {
            "type": "H1",
            "content": "Types of Matrices"
        },
        {
            "type": "P",
            "content": "Based on its rank, a matrix can be primarily classified into two types."
        },
        {
            "type": "P",
            "content": "Full-Rank Matrix"
        },
        {
            "type": "P",
            "content": "A matrix Aâ‚˜â‚™ is called a full-rank matrix if rank(A) = min(m, n). The matrix shown below is an example of a full rank matrix."
        },
        {
            "type": "FIGURE",
            "filename": "64a116ca0c0f151859ad8675ecd9e5a3.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:510/1*G0n6LfPtn4jjJFHUXFX58A.png",
            "caption": null
        },
        {
            "type": "P",
            "content": "Rank-Deficient Matrix"
        },
        {
            "type": "P",
            "content": "The opposite of a full rank matrix is rank deficient i.e. rank(A) < min(m, n). The rank-deficient matrix shown below has a rank of 1, as the columns (or rows) of the matrix are not linearly independent of one another."
        },
        {
            "type": "FIGURE",
            "filename": "c8f6a871a89558e7a3344146aec4bf8c.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:481/1*5gVbap0zv54mcfCWgZEqlA.png",
            "caption": null
        },
        {
            "type": "BLOCKQUOTE",
            "content": "Low-Rank Matrix: A rank-deficient matrix Aâ‚˜â‚™ is called a low-rank matrix if its rank is significantly lower (no fixed threshold) than the minimum number of rows and columns. Mathematically, rank(A) << min(m, n)."
        },
        {
            "type": "H1",
            "content": "Relevant Properties"
        },
        {
            "type": "OL",
            "items": [
                "As previously mentioned, the rank of a matrix is constrained by the minimum of its number of rows and columns."
            ]
        },
        {
            "type": "FIGURE",
            "filename": "67a482e868338ec3d534329fb1a6b891.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:453/1*tNmst6mluR3AZjupaGk7MQ.png",
            "caption": "Prop 1: Rank of a matrix is constrained by the minimum of its number of rows and columns."
        },
        {
            "type": "P",
            "content": "2. Given matrices A and B with rank(A) = m and rank(A) = n, then"
        },
        {
            "type": "FIGURE",
            "filename": "66462da375cfcd6bc02e0bb18b55f67f.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:493/1*MNzwffHQ848V9TbFUfofjA.png",
            "caption": "Prop 2: Rank of the product of two matrices is constrained by the minimum of their individual ranks."
        },
        {
            "type": "BLOCKQUOTE",
            "content": "An intuitive understanding of Matrix Rank: For the purposes of this blog, the rank of a matrix can be perceived as the dimensions of the feature space it represents. In this context, a low-rank matrix of a certain size encapsulated fewer features (or a lower dimensional feature space) than a full-rank matrix of the same dimensions."
        },
        {
            "type": "H1",
            "content": "Rank Decomposition"
        },
        {
            "type": "P",
            "content": "Rank decomposition or factorization of a matrix Aâ‚˜â‚™ is the factorization of A of the form A = Câ‚˜áµ£Fáµ£â‚™ where rank(A) = r. It can be proven that every (finite) matrix has a rank decomposition (proof). Techniques like SVD (Singular Value Decomposition) can be used to construct such a decomposition."
        },
        {
            "type": "P",
            "content": "With that, weâ€™ve covered the necessary background concepts. Letâ€™s dive right into LoRA and explore how it leverages these principles in the context of fine-tuning large AI models."
        },
        {
            "type": "H1",
            "content": "LoRA: Low-Rank Adaptation of Large (Language) Models"
        },
        {
            "type": "P",
            "content": "LoRA is an efficient finetuning technique proposed by Microsoft researchers to adapt large models to specific tasks and datasets. While the paper uses GPT-3 as the test case and focuses on language models and NLP tasks, this technique is quite generalizable, as we will see below. It can be applied to various models in multiple contexts."
        },
        {
            "type": "H1",
            "content": "Hypothesis"
        },
        {
            "type": "P",
            "content": "Many previous works have shown that over-parametrized large models reside on a low intrinsic dimension. The main idea behind LoRA is that the change in weights during model adaptation also has a low intrinsic rank/dimension. Concretely, if Wâ‚™â‚– represents the weights of a single layer and Î”Wâ‚™â‚– represents the change of weights during model adaptation, the authors propose that Î”Wâ‚™â‚– is a low-rank matrix i.e."
        },
        {
            "type": "FIGURE",
            "filename": "93fdb75e9cd3eef52caffc9f7805db35.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:595/1*XPJIyPQjQwQtkxnKejFS6w.png",
            "caption": null
        },
        {
            "type": "BLOCKQUOTE",
            "content": "Why does this make sense?Large models are trained to capture the general representation of their domain (language for LLMs, audio + language for models like Whisper, and vision for image generation models). These models capture a variety of features which allow them to be used for diverse tasks with reasonable zero-shot accuracy. However, when adapting such a model to a specific task or dataset, only a few features need to be emphasized or re-learnt. This means that the update matrix (Î”W) can be a low-rank matrix."
        },
        {
            "type": "H1",
            "content": "Method"
        },
        {
            "type": "P",
            "content": "The technique constrains the rank of the update matrix Î”W using its rank decomposition. It represents Î”Wâ‚™â‚– as the product of 2 low-rank matrices Bâ‚™áµ£ and Aáµ£â‚– where r << min(n, k). This implies that the forward pass of the layer, originally Wx, is modified to Wx + BAx (as shown in the figure below). A random Gaussian initialization is used for A and B is initially to 0, so BA=0 at the start of training. The update BA is additionally scaled with a factor Î±/r."
        },
        {
            "type": "FIGURE",
            "filename": "1ce63c302472685c3cebfe81e8c995d8.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:700/1*e5pYWjrZR3eA_YbCKu8deQ.png",
            "caption": "Fig 2: Modified forward pass using low-rank decomposition."
        },
        {
            "type": "H1",
            "content": "Practical Benefits"
        },
        {
            "type": "OL",
            "items": [
                "Reduction of training time and space: Using the technique shown above, r(n + k) parameters have to be tuned during model adaption. Since r << min(n, k), this is much lesser than the number of parameters that would have to be tuned otherwise (nk). This reduces the time and space required to finetune the model by a large margin. Some numbers from the paper and our experiments are discussed in the sections below.",
                "No additional inference time: If used in production, we can explicitly compute Wâ€™ = W + BA and store the results, performing inference as usual. This guarantees that we do not introduce any additional latency during inference.",
                "Easier task switching: Swapping only the LoRA weights as opposed to all the parameters allows cheaper and faster switching between tasks. Multiple customized models can be created and swapped in and out easily."
            ]
        },
        {
            "type": "P",
            "content": "However, the drawback here is that once the weights are merged to remove additional inference time, the ease of task switching vanishes. Also, it is not straightforward to batch inputs to different tasks with different A and B in a single forward pass. You win some and you lose some, right?"
        },
        {
            "type": "H1",
            "content": "Evaluating the effectiveness of LoRA"
        },
        {
            "type": "P",
            "content": "Having discussed how the technique works and its possible benefits, letâ€™s now explore its efficacy. In the paper, the authors evaluate the performance of LoRA (using RobBert, GPT2, and GPT3) against full finetuning and other parameter/compute efficient techniques. They find that LoRA generally outperforms other efficient finetuning techniques by a significant margin while also providing comparable or better performance than full finetuning. For complete details of their analysis, interested readers can refer to the paper."
        },
        {
            "type": "P",
            "content": "To further explore its effectiveness, we conducted additional experiments in various domains and tasks. In the following subsections, we discuss the results of these experiments, showcasing the versatility and robustness of the LoRA method."
        },
        {
            "type": "H1",
            "content": "Finetuning Whisper-Large-v2 on Common Voice (NL)"
        },
        {
            "type": "P",
            "content": "Whisper is an ASR system which has been trained on a large corpus of data. It is a family of models, each of varying sizes. The smallest model (Whisper-Tiny) contains 39 million parameters whereas the largest model (Whisper-Large-v2 ) contains 1.5 billion parameters. The largest model can perform multilingual automatic speech recognition (ASR). However, its performance can be improved for a particular language by fine-tuning it with data from that language."
        },
        {
            "type": "P",
            "content": "In this experiment, we finetune the model using the Dutch language subset of the Common Voice Dataset. We finetune the large model (with & without LoRA) normally and in a low data regime. Finetuning the model using LoRA with r=32 (where r is the rank of the update matrix) reduces the number of tunable parameters to 15.7 million, which is 1% of the parameters of the entire model."
        },
        {
            "type": "H1",
            "content": "Low Data Regime: Using 1 hour of audio data"
        },
        {
            "type": "P",
            "content": "We finetune Whisper-Large-v2 with and without LoRA on one hour of audio from the Dutch subset of Common Voice. The evaluation results are shown in the table below."
        },
        {
            "type": "P",
            "content": "We see that the performance of the model finetuned using LoRA is similar to the performance of the fully finetuned model. However, as mentioned previously, LoRA allows us to accomplish this in a much shorter time by tuning a minuscule number of parameters (for size, the LoRA checkpoint is only 60MB). Using LoRA (and 8bit optimization), the training took ~4 hours and cost < $5on an Nvidia T4 on Google Cloud."
        },
        {
            "type": "H1",
            "content": "Using a large dataset"
        },
        {
            "type": "P",
            "content": "In this case, we finetuned the same model with the entire Dutch subset of Common Voice (~40 hours). The evaluation results are shown in the table below."
        },
        {
            "type": "P",
            "content": "We see that the performance of the large model finetuned with LoRA (for 5000 steps) is comparable to the performance of the fully finetuned large and medium models. However, using LoRA (and 8bit optimization), the finetuning took ~10 hours and cost < $10 on an Nvidia T4 on Google Cloud."
        },
        {
            "type": "P",
            "content": "Weâ€™ve explored the world of Whisper and how it performs when finetuned with datasets of varying sizes in another blogpost. You can find it here!"
        },
        {
            "type": "H1",
            "content": "Adapting LLaMA ðŸ¦™ to perform a dialogue summarization task"
        },
        {
            "type": "P",
            "content": "LLaMA is a large language model released by the researchers at Meta. Like Whisper, it is a family of models with varying sizes (7B being the smallest and 65B the largest)."
        },
        {
            "type": "P",
            "content": "We finetuned the 7B parameter model on a dialogue summarization task using the Samsum dataset and used ROUGE to evaluate the finetuned model. To test the effectiveness of LoRA at low ranks, the rank of the update matrix was constrained to 4 i.e. r=4. This meant that the number of tunable parameters was 2 million, which is just 0.03% of the total number of model parameters."
        },
        {
            "type": "P",
            "content": "From the table, below we see that it outperforms a fully finetuned Flan-T5-Base model (250 million parameters). Additionally, using a low rank and 8-bit optimization allows us to finetune such a large model on a single Nvidia-T4!"
        },
        {
            "type": "BLOCKQUOTE",
            "content": "Note: This isnâ€™t a fair standalone comparison between models. LLaMA-7B is a much larger foundation model in comparison to Flan-T5-Base and therefore is probably capable of better zero-shot performance on many tasks. However, this comparison aims to demonstrate that for large foundation models, using a very low rank (and thus low compute and time for finetuning) suffices."
        },
        {
            "type": "P",
            "content": "The results from the paper and our experiments demonstrate LoRAâ€™s effectiveness. LoRA provides a compute and parameter efficient method to finetune foundation models without a significant drop in the performance saving both time and money!"
        },
        {
            "type": "FIGURE",
            "filename": "98728c9b7d4e3341f6f9218a6c6a551b.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:500/0*jXzlVe4ZAJaQTKjK.jpg",
            "caption": null
        },
        {
            "type": "H1",
            "content": "LoRA in the Wild"
        },
        {
            "type": "P",
            "content": "Letâ€™s now look at how LoRA is being used in the open-source community. With the recent explosion of large foundation and generative AI models, the open-source community has welcomed LoRA with open arms due to its ability to allow low-resource practitioners to adapt large models. Here, LoRA is primarily being used for two major purposes: Instruct-tuning LLMs and Finetuning Diffusion models."
        },
        {
            "type": "H1",
            "content": "Instruct-tuning Large Language Models"
        },
        {
            "type": "P",
            "content": "With the launch of ChatGPT and techniques like Self-Instruct, the OSS community has been steadily working on tuning large language models to follow instructions."
        },
        {
            "type": "P",
            "content": "The core idea here is simple. Create a dataset of instructions and responses (either using manual curation or ChatGPT) and use LoRA to finetune a pre-trained large language model using this dataset. This method produces models that are reasonably adept at following instructions and answering questions like humans. Interested readers can check out models such as Alpaca-LoRA and Vicuna."
        },
        {
            "type": "FIGURE",
            "filename": "00ac316a66b014eff02429ab8131d9d2.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:700/1*OFvqeFGzoYzuJ8i7whE62A.gif",
            "caption": "Vicuna responding to a userâ€™s question regarding a holiday in Hawaii. (Source)"
        },
        {
            "type": "H1",
            "content": "Finetuning Stable Diffusion"
        },
        {
            "type": "P",
            "content": "Before the launch of ChatGPT and other LLMs like LLaMA, LoRA was primarily used to tune stable diffusion to adapt the style of generated images. The LoRA weights can then be used and shared in a plug-and-play fashion switching them out when a different image generation style is necessary."
        },
        {
            "type": "P",
            "content": "As seen before, the main draw of this technique is its parameter and compute efficiency. A testimony to the popularity of this method in the generative AI community is the existence of the ðŸ¤— Lora Library where people can share their Lora files!"
        },
        {
            "type": "FIGURE",
            "filename": "ca41846b69eff7b394e3615b7105d343.jpg",
            "src": "https://miro.medium.com/v2/resize:fit:700/0*cHt3HICTcCuXkyJ7.png",
            "caption": "Some images generated by finetuning a stable diffusion model with LoRA (Source)"
        },
        {
            "type": "H1",
            "content": "Conclusion"
        },
        {
            "type": "P",
            "content": "To sum it all up: LoRA has two major applications. The first is to finetune large models with low compute, and the second is to adapt large models in a low-data regime. Results from the paper, our experiments and the widespread adoption by the open-source AI community demonstrate its value in the current foundation-model-driven AI environment."
        },
        {
            "type": "P",
            "content": "It democratizes AI, empowering individuals and organizations to use and tune large foundation models without breaking the bank, ensuring that the ability to adapt these models is not just in the hands of a select few!"
        }
    ]
}